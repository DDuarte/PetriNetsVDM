class PetriNet
  /* This class represents petrinets with places, transitions
     and multiple types of arcs */
  instance variables
    public places : set of Place := {}; -- set of places (redundant)
    public arcs : set of Arc := {}; -- set of arcs (redundant)
    public transitions : set of Transition := {}; -- set of transitions (redundant)
    public marking: map Place to nat := {|->}; -- state of the petri net: number of tokens per place
    public starts : Place; -- single starting place
    public finish : set of Place := {}; -- multiple ending places
    inv starts in set places;
    inv finish subset places;
    inv forall arc in set arcs & arc.place in set places;
    inv forall transition in set transitions & (
     forall arc in set transition.inputArcs & arc in set arcs and
     forall arc2 in set transition.outputArcs & arc2 in set arcs
    );

  operations
    public PetriNet: set of Place * Place * set of Place * set of Arc *
                     map Place to nat * set of Transition ==> PetriNet
    PetriNet(p, s, f, a, m, t) == (
      places := p;
      starts := s;
      finish := f;
      arcs := a;
      marking := m;
      transitions := t;
      return self;
    )
    pre dom m = p and
      s in set p and
      f subset p and
      forall a1 in set a & a1.place in set p and
      forall t1 in set t & (
       forall a2 in set t1.inputArcs & a2 in set a and
       forall a3 in set t1.outputArcs & a3 in set a
      );

    -- triggers given transition and returns the new state
    -- of the petrinet. note: it does not change the internal state
    -- of this petrinet instance use executeStep instead
    private trigger: Transition * map Place to nat ==> map Place to nat
    trigger(t, m) == (
      dcl newMarking: map Place to nat := m;

      for all arc in set t.inputArcs do (
        if not arc.isEnabled(newMarking) then
          return m;
        newMarking := arc.trigger(t, newMarking);
      );

      for all arc in set t.outputArcs do (
        if not arc.isEnabled(newMarking) then
          return m;
        newMarking := arc.trigger(t, newMarking);
      );

      return newMarking;
    )
    pre t in set transitions and dom m subset places
    post dom RESULT subset places;

    -- triggers given transition and changes marking accordingly
    public executeStep: Transition ==> ()
    executeStep(t) == (
      marking := trigger(t, marking);
    )
    pre t in set transitions;

    -- returns true if a marking is reachable
    -- Reachability def: "Given a computational (potentially infinite state)
    -- system with a set of allowed rules or transformations,
    -- decide whether a certain state of a system is reachable
    -- from a given initial state of the system."
    public isReachable: map Place to nat ==> bool
    isReachable(targetMarking) == (
      dcl stack: DFSStack := new DFSStack();
      dcl currentInputMarking: map Place to nat := marking;
      dcl currentOutputMarking: map Place to nat := marking;
      dcl previousMarkings: set of map Place to nat := {};

      stack.push(new DFSElement(marking, new Transition("Start", { }, { })));

      while not stack.empty() do (

        currentInputMarking := stack.pop().marking;

        for all transition in set transitions do (

          currentOutputMarking := trigger(transition, currentInputMarking);

          -- if target marking is found
          if (currentOutputMarking = targetMarking) then return true;

          -- if marking is not already explored
          if (currentOutputMarking not in set previousMarkings) then (
            stack.push(new DFSElement(currentOutputMarking, transition));
            previousMarkings := previousMarkings union {currentOutputMarking};
          )
        );

      );

      return false;
    )
    pre dom targetMarking subset places;

    -- returns all sequences of transitions from an initial marking and a target marking
    public getAllSequences: map Place to nat * map Place to nat ==> set of seq of Transition
    getAllSequences(initialMarking, targetMarking) == (
      dcl stack: DFSStack := new DFSStack();
      dcl currentDFSElement: DFSElement;
      dcl currentInputMarking: map Place to nat := initialMarking;
      dcl currentTransition: Transition;
      dcl currentOutputMarking: map Place to nat := initialMarking;
      dcl previousMarkings: set of map Place to nat := {};
      dcl transitionSeqs: set of seq of Transition := {};
      dcl sequence: seq of Transition;
      dcl sequencePath: seq of Transition := [];
      dcl newMarkingsGenerated: bool := false;
      dcl dummyTransition: Transition := new Transition("Start", { }, { });
      
      stack.push(new DFSElement(initialMarking, dummyTransition)); -- FIX ME

      while not stack.empty() do (

        currentDFSElement := stack.pop();
        currentTransition := currentDFSElement.transition;
        currentInputMarking := currentDFSElement.marking;
        
        newMarkingsGenerated := false;

        if (currentTransition <> dummyTransition) then
          sequencePath := [currentTransition] ^ sequencePath;

        for all transition in set transitions do (

          currentOutputMarking := trigger(transition, currentInputMarking);

          -- if target marking is found
          if (currentOutputMarking = targetMarking and currentOutputMarking <> currentInputMarking and currentOutputMarking not in set previousMarkings) then (

            if (len sequencePath <> 0) then (
              transitionSeqs := transitionSeqs union {sequencePath ^ [transition]};
            );
          );

          -- if marking is not already explored
          if (currentOutputMarking not in set previousMarkings) then (
            newMarkingsGenerated := true;
            stack.push(new DFSElement(currentOutputMarking, transition));
            previousMarkings := previousMarkings union {currentOutputMarking};
          );
          
          -- reached a dead end, remove sequence from path, a backtracking will occur
          if (not newMarkingsGenerated) then (
            if (len sequencePath > 0) then 
              sequencePath := tl sequencePath;
          );
          
        );

      );

      return transitionSeqs;
    )
    pre dom initialMarking subset places and dom targetMarking subset places;

end PetriNet
