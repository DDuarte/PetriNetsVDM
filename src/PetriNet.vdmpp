class PetriNet
  instance variables
    public places : set of Place := {};
    public arcs : set of Arc := {};
    public transitions : set of Transition := {};
    public marking: map Place to nat := {|->};
    public starts : Place;
    public finish : set of Place := {};
    inv starts in set places;
    inv finish subset places;
    inv forall arc in set arcs & arc.place in set places and arc.transition in set transitions;

  operations
    public PetriNet: set of Place * Place * set of Place * set of Arc * map Place to nat * set of Transition ==> PetriNet
    PetriNet(p, s, f, a, m, t) == (
      places := p;
      starts := s;
      finish := f;
      arcs := a;
      marking := m;
      transitions := t;
      return self;
    )
    pre dom m = p and
      s in set p and
      f subset p and
      forall a1 in set a & a1.place in set p and a1.transition in set t;

    private trigger: Transition ==> map Place to nat
    trigger(t) == (
    	dcl newMarking: map Place to nat := marking;
      dcl inputArcs: set of InputArc := {};
      dcl outputArcs: set of OutputArc := {};
      dcl selectedOutputArcs: set of OutputArc := {};
      dcl inputArcsTokens: nat := 0;

      for all arc in set arcs do (
        if arc.transition = t then (
           if isofclass(InputArc, arc) and arc.isEnabled(marking) then
             inputArcs := inputArcs union {arc}
           else if isofclass(OutputArc, arc) then
             outputArcs := outputArcs union {arc}
        )
      );

      if card inputArcs = 0 or card outputArcs = 0 then return newMarking;

      for all inputArc in set inputArcs do (
        inputArcsTokens := inputArcsTokens + marking(inputArc.place)
      );

      for all outputArc in set outputArcs do (
        if outputArc.weight <= inputArcsTokens then
          selectedOutputArcs := selectedOutputArcs union {outputArc}
      );

      -- update marking

      for all inputArc in set inputArcs do (
        newMarking(inputArc.place) := newMarking(inputArc.place) - inputArc.weight;
      );

      for all outputArc in set selectedOutputArcs do (
        newMarking(outputArc.place) := newMarking(outputArc.place) + outputArc.weight;
      );
      
      return newMarking; 
    )
    pre t in set transitions;
    
    private simulateTrigger: Transition * map Place to nat ==> map Place to nat
    simulateTrigger(t, inputMarking) == (
    	dcl newMarking: map Place to nat := inputMarking;
      dcl inputArcs: set of InputArc := {};
      dcl outputArcs: set of OutputArc := {};
      dcl selectedOutputArcs: set of OutputArc := {};
      dcl inputArcsTokens: nat := 0;

      for all arc in set arcs do (
        if arc.transition = t then (
           if isofclass(InputArc, arc) and arc.isEnabled(inputMarking) then
             inputArcs := inputArcs union {arc}
           else if isofclass(OutputArc, arc) then
             outputArcs := outputArcs union {arc}
        )
      );

      if card inputArcs = 0 or card outputArcs = 0 then return newMarking;

      for all inputArc in set inputArcs do (
        inputArcsTokens := inputArcsTokens + inputMarking(inputArc.place)
      );

      for all outputArc in set outputArcs do (
        if outputArc.weight <= inputArcsTokens then
          selectedOutputArcs := selectedOutputArcs union {outputArc}
      );

      -- update marking

      for all inputArc in set inputArcs do (
        newMarking(inputArc.place) := newMarking(inputArc.place) - inputArc.weight;
      );

      for all outputArc in set selectedOutputArcs do (
        newMarking(outputArc.place) := newMarking(outputArc.place) + outputArc.weight;
      );
      
      return newMarking; 
    )
    pre t in set transitions;
    
    public executeStep: Transition ==> ()
    executeStep(t) == (
    	marking := trigger(t);
    );
    
    public isReachable: map Place to nat ==> bool
    isReachable(targetMarking) == (
    	dcl stack: Stack := new Stack();
    	dcl currentInputMarking: map Place to nat := marking;
    	dcl currentOutputMarking: map Place to nat := marking;
    	dcl previousMarkings: set of map Place to nat := {};
    	stack.push(marking);
    	
    	while not stack.empty() do (
    		currentInputMarking := stack.pop();
    		for all transition in set transitions do (
    			currentOutputMarking := simulateTrigger(transition, currentInputMarking);
    			if (currentOutputMarking = targetMarking) then return true;
    			
    			if (currentOutputMarking not in set previousMarkings) then (stack.push(currentOutputMarking);
    			previousMarkings := previousMarkings union {currentOutputMarking};
    			)
    		);
    	);
    	
    	return false;
    );

end PetriNet
