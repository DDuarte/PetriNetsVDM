class PetriNet
  instance variables
    public places : set of Place := {};
    public arcs : set of Arc := {};
    public transitions : set of Transition := {};
    public marking: map Place to nat := {|->};
    public starts : Place;
    public finish : set of Place := {};
    inv starts in set places;
    inv finish subset places;
    -- inv forall arc in set arcs & arc.place in set places and arc.transition in set transitions;

  operations
    public PetriNet: set of Place * Place * set of Place * set of Arc * map Place to nat * set of Transition ==> PetriNet
    PetriNet(p, s, f, a, m, t) == (
      places := p;
      starts := s;
      finish := f;
      arcs := a;
      marking := m;
      transitions := t;
      return self;
    )
    pre dom m = p and
      s in set p and
      f subset p;
      -- forall a1 in set a & a1.place in set p and a1.transition in set t;

    private trigger: Transition * map Place to nat ==> map Place to nat
    trigger(t, m) == (
      dcl newMarking: map Place to nat := m;

      for all arc in set t.inputArcs do (
        if not arc.isEnabled(newMarking) then
          return m;
        newMarking := arc.trigger(t, newMarking);
      );

      for all arc in set t.outputArcs do (
        if not arc.isEnabled(newMarking) then
          return m;
        newMarking := arc.trigger(t, newMarking);
      );

      return newMarking;
    );
    -- pre t in set transitions;

    public executeStep: Transition ==> ()
    executeStep(t) == (
      marking := trigger(t, marking);
    );

    public isReachable: map Place to nat ==> bool
    isReachable(targetMarking) == (
      dcl stack: DFSStack := new DFSStack();
      dcl currentInputMarking: map Place to nat := marking;
      dcl currentOutputMarking: map Place to nat := marking;
      dcl previousMarkings: set of map Place to nat := {};

      stack.push(new DFSElement(marking, new Transition("Start", { }, { }))); -- FIX ME

      while not stack.empty() do (

        currentInputMarking := stack.pop().marking;

        for all transition in set transitions do (

          currentOutputMarking := trigger(transition, currentInputMarking);

          -- if target marking is found
          if (currentOutputMarking = targetMarking) then return true;

          -- if marking is not already explored
          if (currentOutputMarking not in set previousMarkings) then (
            stack.push(new DFSElement(currentOutputMarking, transition));
            previousMarkings := previousMarkings union {currentOutputMarking};
          )
        );

      );

      return false;
    );

    public getAllSequences: map Place to nat * map Place to nat ==> set of seq of Transition
    getAllSequences(initialMarking, targetMarking) == (
      dcl stack: DFSStack := new DFSStack();
      dcl currentInputMarking: map Place to nat := initialMarking;
      dcl currentOutputMarking: map Place to nat := initialMarking;
      dcl previousMarkings: set of map Place to nat := {};
      dcl transitionSeqs: set of seq of Transition := {};
      dcl sequence: seq of Transition;

      stack.push(new DFSElement(initialMarking, new Transition("Start", { }, { }))); -- FIX ME

      while not stack.empty() do (

        currentInputMarking := stack.pop().marking;

        for all transition in set transitions do (

          currentOutputMarking := trigger(transition, currentInputMarking);

          -- if target marking is found
          if (currentOutputMarking = targetMarking) then (
            sequence := stack.getReverseTransitionSequence();
            transitionSeqs := transitionSeqs union {sequence};
          );

          -- if marking is not already explored
          if (currentOutputMarking not in set previousMarkings) then (
            stack.push(new DFSElement(currentOutputMarking, transition));
            previousMarkings := previousMarkings union {currentOutputMarking};
          )
        );

      );

      return transitionSeqs;
    );

end PetriNet
